#include "all.h"
#include "yacc.h"
#include <vector>

#pragma warning(push)
#pragma warning(disable:4701)
//----------------------------

#define YYINITDEPTH 200       //initial size of the parser's stacks

#define INIT_CODE_SIZE  0x8000
#define INIT_DATA_SIZE  0x8000

                              //parser internal
#define YYEMPTY -2
#define YYEOF 0
#define YYTERROR  1

//#define YYERROR_VERBOSE
#define VERBOSE               //enable verbose code compilation
#define YYDEBUG 1             //debug info
                              //include tables generated by bison parser
#include "c"

//----------------------------

void C_compile_process::Error(const char *s, bool warn, bool display_loc){

   if(!warn)
      ++num_errors;
   if(display_loc){
      int i = include_files.size();
      if(i>1){
         C_fstr str("File: %s", (const char*)include_files.back().name);
         if(err_fnc) err_fnc(str, cb_err_context, yyloc.l, yyloc.r, warn);
         else puts(str);
         --i;
         while(i--){
            C_fstr str("  included from %s (%i)", (const char*)include_files[i].name, include_files[i].loc.l);
            if(err_fnc) err_fnc(str, cb_err_context, yyloc.l, yyloc.r, warn);
            else puts(str);
         }
      }
   }
   C_str str;
   if(display_loc)
      str = C_fstr("%s! %s: %s", (warn ? "Warning" : "Error"), ((yyloc.l && yyloc.r) ? (const char*)C_fstr("(%i, %i)", yyloc.l, yyloc.r) : ""), s);
   else
      str = s;
   if(err_fnc) err_fnc(str, cb_err_context, yyloc.l, yyloc.r, warn);
   //else puts(str);
}

//----------------------------

#define ERROR(s) compile_process.Error(s)
#define MSG(s) compile_process.Error(s, false, false)
#define WARNING(s) compile_process.Error(s, true)

//#define WARNING(s) compile_process.err_fnc(s, compile_process.cb_err_context, yylloc.l, yylloc.r, true)

//----------------------------

ISL_RESULT C_script::ProcessCommandLine(const char *cl, dword flags,
   C_compile_process &compile_process, C_scope &yyscope,
   C_vector<byte> &tmp_code, C_vector<byte> &tmp_data, C_vector<S_symbol_info> &tmp_reloc,
   C_vector<S_symbol_info> &tmp_symbols, C_vector<byte> &tmp_templ){

   if(!cl)
      return ISL_OK;

   int i;
   int num;
   char option;

   while(*cl){
      switch(*cl){
      case '-':
      case '/':
         {
            option = *(++cl)++;
            switch(option){
            case 'I':         //force include file
               {
                  char fname[256];
                  i = sscanf(cl, "%255s%n", fname, &num);
                  if(i!=1) goto bad_param;
                  cl += num;
                              //for now, add dependency, which will be processed later
                  compile_process.AddDependency(fname);
                  /*
                  ISL_RESULT ir = ProcessFile(fname, flags | ISLCOMP_SEARCH_INCL_PATHS,
                     compile_process, yyscope, tmp_code, tmp_data, tmp_reloc, tmp_symbols, tmp_templ,
                     &debug_info);
                  if(ISL_FAIL(ir))
                     return ir;
                     */
               }
               break;

            case 'i':
               {
                  char name[256];
                  i = sscanf(cl, "%255s%n", name, &num);
                  if(i!=1) goto bad_param;
                  cl += num;
                  if(num && name[num-1]!='\\'){
                     name[num++] = '\\';
                     name[num] = 0;
                  }
                  compile_process.include_paths.push_back(name);
               }
               break;

            default:
               compile_process.err_fnc(C_fstr("Invalid compile option: '%c'", option), compile_process.cb_err_context, 0, 0, 0);
               return ISLERR_INVALIDOPTIONS;
            }
         }
         break;
      case ' ':
         ++cl;
         break;
      default:
         compile_process.err_fnc(C_fstr("Invalid compile options: %s", cl), compile_process.cb_err_context, 0, 0, 0);
         return ISLERR_INVALIDOPTIONS;
      }
   }
   return ISL_OK;

bad_param:
   compile_process.err_fnc(C_fstr("Bad parameters for command-line option '%c': \"%s\"", option, cl), compile_process.cb_err_context, 0, 0, 0);
   return false;
}

//----------------------------

ISL_RESULT C_script::ProcessFile(const char *fname, dword flags,
   C_compile_process &compile_process, C_scope &yyscope,
   C_vector<byte> &tmp_code, C_vector<byte> &tmp_data, C_vector<S_symbol_info> &tmp_reloc,
   C_vector<S_symbol_info> &tmp_symbols, C_vector<byte> &tmp_templ,
   t_debug_info *debug_info){

   int i;
   dword verbose = (flags&ISLCOMP_VERBOSE) ? 1 : 0;

                              //variables for free use in actions
   C_str str;
   C_c_type yylval;           //current lvalue being evaluated
   S_location &yylloc = compile_process.yyloc;
   yylloc.Home();

   C_cache ck;

   if(!ck.open(fname, CACHE_READ)){
      bool ok = false;
      if(flags&ISLCOMP_SEARCH_INCL_PATHS){
         for(dword i=0; i<compile_process.include_paths.size(); i++){
            if(ck.open(compile_process.include_paths[i]+fname, CACHE_READ)){
               ok = true;
               break;
            }
         }
      }
      if(!ok){
         yylloc.l = yylloc.r = 0;
         ERROR(C_fstr("unable to open '%s'", fname));
         return ISLERR_NOFILE;
      }
   }

   compile_process.curr_dbg_info = &compile_process.debug_info[fname];

   compile_process.AddDependency(fname);

   compile_process.include_files.push_back(S_incl_file(&ck, fname));

                              //lookahead token as an internal (translated) token number
   int yychar1;               

                              //state stack
   stack<short, vector<short> > yy_st_stack;
   //yy_st_stack.reserve(YYINITDEPTH);

                              //semantic value stack
   C_stack<C_c_type, C_vector<C_c_type> > yy_sval_stack;
   yy_sval_stack.reserve(YYINITDEPTH);

                              //for converting func return value
   C_c_type fnt_ret_type = new C_c_type_imp; fnt_ret_type->Release();

                              //enum creation
   int recent_enum_val;

                              //for enabling use of continue and break
   int iter_stmt = 0, switch_stmt = 0;
   C_c_type switch_expr_type = new C_c_type_imp; switch_expr_type->Release();

                              //location stack
   C_stack<S_location, C_vector<S_location> > yy_loc_stack;
   yy_loc_stack.reserve(YYINITDEPTH);
   yylloc.Home();

                              //the variable used to return
                              //semantic values from the action
                              //routines
   int yylen;

#ifdef VERBOSE
   if(verbose) puts("Starting parse");
#endif

   short yystate = 0;
   int yyerrstatus = 0;         //number of tokens to shift before error messages enabled
                              //cause a token to be read.
   int yychar = YYEMPTY;
                              //Push a new state, which is found in yystate.
                              //In all cases, when you get here, the value and location stacks
                              //have just been pushed. so pushing a state here evens the stacks.
   int yyn;
yynewstate:
   C_c_type yyval;
   while(true){
      yy_st_stack.push(yystate);
#ifdef VERBOSE
      if(verbose==2)
         puts(C_fstr("Entering state %i", yystate));
#endif
                              //Do appropriate processing given the current state.
                              //Read a lookahead token if we need one and don't already have one.
                              //First try to decide what to do without reference to lookahead token.
      yyn = yypact[yystate];
      if(yyn==YYFLAG)
         break;
                              //Not known => get a lookahead token if don't already have one.
                              //yychar is either YYEMPTY or YYEOF or a valid token in external form.

      if(yychar==YYEMPTY){
#ifdef VERBOSE
         if(verbose)
            puts("Reading a token: ");
#endif
         //yylval.Reset();
re_read:
         yylval = new C_c_type_imp; yylval->Release();
         yychar = compile_process.yyLex(yylval, yyscope, str);
         if(yychar < 0){
            ERROR(str);
            if(yychar==-1)
               goto re_read;
            yychar = -yychar;
         }
      }
                              //Convert token to internal form
                              //(in yychar1) for indexing tables with
      if(yychar<=0){          //This means end of input.
         yychar1 = 0;
         yychar = YYEOF;
#ifdef VERBOSE
         if(verbose)
            puts("Now at end of input.");
#endif
      }else{
         yychar1 = YYTRANSLATE(yychar);
#ifdef VERBOSE
         if(verbose)
            puts(C_fstr("Next token is %i %s (%i, %i)", yychar,  yytname[yychar1], yylloc.l, yylloc.r));
#endif
      }

      yyn += yychar1;
      if(yyn<0 || yyn>YYLAST || yycheck[yyn]!=yychar1)
         break;

      yyn = yytable[yyn];

                              //yyn is what to do for this token type in this state.
                              //Negative => reduce, -yyn is rule number.
                              //Positive => shift, yyn is new state.
                              //New state is final state => don't bother to shift,
                              //just return success.
                              //0, or most negative number => error.
      if(yyn<0){
         if(yyn==YYFLAG)
            goto yyerrlab;
         yyn = -yyn;
         goto yyreduce;
      }else
      if(yyn==0)
         goto yyerrlab;

      if(yyn==YYFINAL)
         goto done_ok;
                              //Shift the lookahead token.
#ifdef VERBOSE
      if(verbose==2)
         puts(C_fstr("Shifting token %i %s", yychar, yytname[yychar1]));
#endif
                              //Discard the token being shifted
                              //unless it is eof.
      if(yychar!=YYEOF)
         yychar = YYEMPTY;

      yy_sval_stack.push(yylval);

      yy_loc_stack.push(yylloc);

                              //count tokens shifted since error;
                              //after three, turn off error status.
      if(yyerrstatus)
         yyerrstatus--;
      yystate = (short)yyn;
   }
   yyn = yydefact[yystate];
   if(yyn==0)
      goto yyerrlab;

                              //Do a reduction.  yyn is the number of a rule to reduce with.
yyreduce:
   yylen = yyr2[yyn];

#ifdef VERBOSE
   if(verbose){
      puts(C_fstr("Reducing %i value%s via rule %i (line %i)", yylen, (yylen>1 ? "s" : ""), yyn, (int)yyrline[yyn]));
   }
#endif
//----------------------------
                              //default action - assign first value to
                              //yyval, we use fastswap for swapping
                              //objects, as it doesn't employ constructors
                              //and destructors, and right value is no
                              //longer needed
//#define DEFAULT_ACTION  FastSwap(yyval, yy_sval_stack[1-yylen])
#define DEFAULT_ACTION yyval = yy_sval_stack[1-yylen]
#define RESET_CURRENT yyval = new C_c_type_imp; yyval->Release();
                              //actions - compiled parser file
#include "a"
//----------------------------
   for(i=0; i<yylen; i++){
      yy_st_stack.pop();
      yy_sval_stack.pop();
      yy_loc_stack.pop();
   }

#ifdef VERBOSE
/*
   if(verbose){
      short *ssp1=yyss-1;
      puts("state stack now");
      while(ssp1!=yyssp) cout<<*(++ssp1);
      puts("\n");
   }
   */
#endif
   yy_sval_stack.push(yyval);
   yyval = NULL;
   /*
   yy_sval_stack.push(C_c_type());
   FastSwap(yyval, yy_sval_stack.top());
   */


   yy_loc_stack.push(yylloc);

   //Now "shift" the result of the reduction.
   //Determine what state that goes to,
   //based on the state we popped back to
   //and the rule number reduced by.

   yyn = yyr1[yyn];

   yystate = short(yypgoto[yyn-YYNTBASE] + yy_st_stack.top());

   if(yystate>=0 && yystate<=YYLAST && yycheck[yystate]==yy_st_stack.top()){
      yystate = yytable[yystate];
   }else{
      yystate = yydefgoto[yyn-YYNTBASE];
   }
   goto yynewstate;

yyerrlab:                     //here on detecting error

   if(!yyerrstatus && yy_sval_stack.size()){
                              //If not already recovering from
                              //an error, report this error.
#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];
      if(yyn>YYFLAG && yyn<YYLAST){
         C_str s_err;
                              //count expected combinations
         int count = 0;
         for(int x=1; x<(sizeof(yytname)/sizeof(char*)); x++)
            if(yycheck[x+yyn]==x)
               ++count;

         s_err = ERR_SYNTAX;

         if(count<5){
            for(count=0, x=1; x<(sizeof(yytname)/sizeof(char*)); x++)
            if(yycheck[x+yyn]==x){
               s_err += count ? " or " : ", expexting ";
               s_err += yytname[x];
               ++count;
            }
         }
         ERROR(s_err);
      }else{
         ERROR(ERR_SYNTAX);
      }
#else
      ERROR(ERR_SYNTAX);
#endif
   }
   /*
yyerrlab1:
      //here on error raised explicitly by an action
   if(yyerrstatus==3){
      //if just tried and failed to reuse lookahead
      //token after an error, discard it.
      //return failure if at end of input
      if(yychar==YYEOF) return ISLERR_BADSCRIPT;
#ifdef VERBOSE
      if(verbose) cout<<"Discarding token " <<yychar <<" " <<yytname[yychar1] <<endl;
#endif
      yychar=YYEMPTY;
   }
                              //Else will try to reuse lookahead token
                              //after shifting the error token.
                              //Each real token shifted decrements this
   yyerrstatus=3;
   goto yyerrhandle;
   */

yyerrdefault:
                              //current state does not do anything
                              //special for the error token.
#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
                              //If its default is to accept any token, ok.  Otherwise pop it.
   yyn = yydefact[yystate];
   if(yyn)
      goto yydefault;
#endif

yyerrpop:
                              //pop the current state because it cannot handle the error token
   if(yy_st_stack.empty() || !yy_sval_stack.size())
   //if(yy_st_stack.empty())
   {
//done_empty:
      while(compile_process.include_files.size()){
         if(compile_process.include_files.size() > 1)
            delete compile_process.include_files.back().ck;
         compile_process.include_files.pop_back();
      }
                              //allow empty sources to be successful
      if(compile_process.num_errors)
         return ISLERR_BADSCRIPT;
      return (yy_sval_stack.size() || yy_st_stack.size()) ? ISLERR_BADSCRIPT : ISL_OK;
   }
   //if(!yy_sval_stack.size()) goto done_ok;

   yy_sval_stack.pop();

   yy_st_stack.pop();
   yystate = yy_st_stack.top();

   yy_loc_stack.pop();

#ifdef VERBOSE
/*
   if(verbose) {
      short *ssp1=yyss-1;
      cout<<"Error: state stack now";
      while(ssp1!=yyssp) cout<<*(++ssp1);
      cout<<endl;
   }
   */
#endif

//yyerrhandle:
   yyn = yypact[yystate];
   if(yyn==YYFLAG)
      goto yyerrdefault;

   yyn += YYTERROR;
   if(yyn<0 || yyn>YYLAST || yycheck[yyn]!=YYTERROR)
      goto yyerrdefault;

   yyn = yytable[yyn];
   if(yyn<0){
      if(yyn==YYFLAG)
         goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
   }else
   if(!yyn){
      goto yyerrpop;
   }

   if(yyn==YYFINAL)
      goto done_ok;

#ifdef VERBOSE
   if(verbose==2)
      puts("Shifting error token, ");
#endif

   yy_sval_stack.push(yylval);

   yy_loc_stack.push(yylloc);

   yystate = (short)yyn;
   goto yynewstate;

done_ok:
   assert(compile_process.include_files.size()==1);
   compile_process.include_files.pop_back();
   if(compile_process.num_errors){
      return ISLERR_BADSCRIPT;
   }

   if(debug_info){
      for(t_debug_info::const_iterator it = compile_process.debug_info.begin(); it!=compile_process.debug_info.end(); it++){
         if((*it).second.size())
            debug_info->insert(*it);
      }
   }

   if(yyscope.GetLevel()!=0){
      if(verbose)
         puts(C_fstr("finished with scope level %i", yyscope.GetLevel()));
      return ISLERR_GENERIC;
   }
   return ISL_OK;
}

//----------------------------

ISL_RESULT C_script::CompileInternal(const char *fname, dword flags,
   const char *cmd_line,
   T_report_err *err_fnc1, void *cb_context){

   C_compile_process compile_process;
                              //setup error function
   compile_process.err_fnc = err_fnc1;
   compile_process.cb_err_context = cb_context;

   int i;

                              //build code, data, symbol and reloc segments
                              //automatically expanded
   C_vector<byte> tmp_code;
   tmp_code.reserve(INIT_CODE_SIZE);
   C_vector<byte> tmp_data;
   tmp_data.reserve(INIT_DATA_SIZE);
   C_vector<S_symbol_info> tmp_reloc;
   tmp_reloc.reserve(1024);
   C_vector<S_symbol_info> tmp_symbols;
   tmp_symbols.reserve(1024);
   C_vector<byte> tmp_templ;
   C_scope yyscope;           //scope for keeping namespaces

   ISL_RESULT ir = ProcessCommandLine(cmd_line, flags,
      compile_process, yyscope, tmp_code, tmp_data, tmp_reloc, tmp_symbols, tmp_templ);
   if(ISL_FAIL(ir))
      return ir;


   if(flags&(ISLCOMP_PRECOMPILE | ISLCOMP_FORCE_PRECOMPILED)){
      C_str fname1;
      {
         for(i=0; fname[i] && fname[i]!='.'; i++);
         char *cp = new char[i+1];
         strncpy(cp, fname, i);
         cp[i] = 0;
         fname1 = C_fstr("%s.pcp", cp);
         delete[] cp;
      }

      C_cache ck;
      if(ck.open(fname1, CACHE_READ)){
      //PC_dta_stream dta = DtaCreateStream(fname1);
      //if(dta)
                              //read header
         S_pcp_header hdr;
         ck.read(&hdr, sizeof(hdr));
         if(hdr.version==PCP_VERSION){
                              //read filename
            char stored_fn[257];
            ck.getline(stored_fn, 256, 0);
            if(!stricmp(stored_fn, fname)){
                              //check all dependencies
               C_buffer<C_str> tmp_dep;
               tmp_dep.assign(hdr.num_dependencies);
               bool dep_ok = true;
               for(dword di=0; di<hdr.num_dependencies; di++){
                  __int64 file_time;
                  if(ck.read(&file_time, sizeof(file_time))!=sizeof(file_time))
                     break;
                  char dep_fname[257];
                  ck.getline(dep_fname, 256, 0);
                  if(dep_ok){
                     PC_dta_stream dep_dta = DtaCreateStream(dep_fname);
                     if(!dep_dta){
                        for(dword ii=0; ii<compile_process.include_paths.size(); ii++){
                           if(dep_dta = DtaCreateStream(compile_process.include_paths[ii]+dep_fname))
                              break;
                        }
                     }
                     if(!dep_dta)
                        dep_ok = false;
                     else{
                        __int64 ftime;
                        dep_dta->GetTime((dword*)&ftime);
                        dep_dta->Release();
                        if(ftime!=file_time)
                           dep_ok = false;
                     }
                  }
                  tmp_dep[di] = dep_fname;
               }
               if(dep_ok || (flags&ISLCOMP_FORCE_PRECOMPILED)){
                                 //success, use precompiled script
                  code.assign(hdr.code_size);
                  ck.read(code.begin(), code.size());

                  data.assign(hdr.data_size);
                  ck.read(data.begin(), data.size());

                  reloc_data = new S_symbol_info[hdr.num_reloc_data];
                  ck.read(reloc_data, hdr.num_reloc_data*sizeof(S_symbol_info));

                  reloc_symbols = new S_symbol_info[hdr.num_reloc_symbols];
                  ck.read(reloc_symbols, hdr.num_reloc_symbols*sizeof(S_symbol_info));

                  table_templ.assign(hdr.table_templ_size);
                  ck.read(table_templ.begin(), table_templ.size());
                  if(table_templ.size()){
                     C_table_template *tt = (C_table_template*)table_templ.begin();
                     tt->te = (CPC_table_element)&tt[1];
                  }
                                 //set comile time
                  //comp_time = hdr.comp_time;
                  dependency = tmp_dep;

                  comp_ok = true;
                  return ISL_UPTODATE;
               }
            }
         }
      }
   }

                              //preprocess all included files (in dependency list)
   {
      dword num_init_dep = compile_process.dependency.size();
      for(dword dep_i=0; dep_i<num_init_dep; dep_i++){
         ISL_RESULT ir = ProcessFile(compile_process.dependency[dep_i], flags | ISLCOMP_SEARCH_INCL_PATHS,
            compile_process, yyscope, tmp_code, tmp_data, tmp_reloc, tmp_symbols, tmp_templ,
            &debug_info);
         if(ISL_FAIL(ir))
            return ir;

      }
   }


   ir = ProcessFile(fname, flags, compile_process, yyscope,
      tmp_code, tmp_data, tmp_reloc, tmp_symbols, tmp_templ, &debug_info);
   if(ISL_FAIL(ir))
      return ir;

   code.assign(&tmp_code.front(), (&tmp_code.back())+1);
   if(flags&ISLCOMP_VERBOSE)
      puts(C_fstr("code size: %i", code.size()));

   if(tmp_data.size())
      data.assign(&tmp_data.front(), (&tmp_data.back())+1);
   if(flags&ISLCOMP_VERBOSE)
      puts(C_fstr("data size: %i", data.size()));

   if(tmp_templ.size())
      table_templ.assign(&tmp_templ.front(), (&tmp_templ.back())+1);
   if(table_templ.size()){
      C_table_template *tt = (C_table_template*)table_templ.begin();
      tt->te = (CPC_table_element)&tt[1];
   }


   reloc_data = new S_symbol_info[tmp_reloc.size()+1];
   memcpy(reloc_data, &tmp_reloc.front(), tmp_reloc.size()*sizeof(S_symbol_info));
   reloc_data[tmp_reloc.size()].type = SI_NULL;

   reloc_symbols = new S_symbol_info[tmp_symbols.size()+1];
   memcpy(reloc_symbols, &tmp_symbols.front(), tmp_symbols.size()*sizeof(S_symbol_info));
   reloc_symbols[tmp_symbols.size()].type = SI_NULL;

   dependency.assign(&compile_process.dependency.front(), (&compile_process.dependency.back())+1);

                              //set comile time
   //OsGetCurrentTimeDate(comp_time);

   if(flags&ISLCOMP_PRECOMPILE){
                              //write preprocess info
      C_str fname1;
      {
         for(i=0; fname[i] && fname[i]!='.'; i++);
         char *cp = new char[i+1];
         strncpy(cp, fname, i);
         cp[i] = 0;
         fname1 = C_fstr("%s.pcp", cp);
         delete[] cp;
      }

      C_cache ck;
      bool open_ok = ck.open(fname1, CACHE_WRITE);
      if(!open_ok){
         if(OsMakeFileHidden(fname1, false))
            open_ok = ck.open(fname1, CACHE_WRITE);
      }
      //if(!open_ok)
      if(open_ok){
                              //create and write header
         S_pcp_header h;
         h.version = PCP_VERSION;
         h.code_size = code.size();
         h.data_size = data.size();
         h.num_reloc_data = tmp_reloc.size() + 1;
         h.num_reloc_symbols = tmp_symbols.size() + 1;
         h.table_templ_size = table_templ.size();
         h.num_dependencies = dependency.size();
         ck.write((char*)&h, sizeof(h));
         C_str str(fname);
         str.ToLower();
         ck.write((const char*)str, str.Size()+1);
                              //write dates of dependent files
         for(dword di=0; di<h.num_dependencies; di++){
            const char *dep_fname = dependency[di];
                              //save dependency info
            PC_dta_stream dta = DtaCreateStream(dep_fname);
            if(!dta){
               for(dword ii=0; ii<compile_process.include_paths.size(); ii++){
                  if(dta = DtaCreateStream(compile_process.include_paths[ii]+dep_fname))
                     break;
               }
            }
            assert(dta);
            if(!dta)
               return ISLERR_GENERIC;
            __int64 ftime;
            dta->GetTime((dword*)&ftime);
            dta->Release();
            ck.write((char*)&ftime, sizeof(ftime));
            ck.write(dep_fname, strlen(dep_fname)+1);
         }

                              //write code, data, reloc data, reloc symbols
         ck.write((char*)code.begin(), code.size());
         ck.write((char*)data.begin(), data.size());
         ck.write((char*)reloc_data, h.num_reloc_data * sizeof(S_symbol_info));
         ck.write((char*)reloc_symbols, h.num_reloc_symbols * sizeof(S_symbol_info));
         ck.write((char*)table_templ.begin(), table_templ.size());

         ck.close();
         if(flags&ISLCOMP_PRECOMPILE_HIDDEN)
            OsMakeFileHidden(fname1, true);
      }else{
                              //can't write precompile info - issue warning
         compile_process.err_fnc(C_fstr("Warning: can't write into file: '%s' (please make sure the file is not read-only)", (const char*)fname1),
            compile_process.cb_err_context, 0, 0, true);
      }
   }
   comp_ok = true;
   return ISL_OK;
}

//----------------------------

void C_script::RelocateTableTemplate(){

   const S_symbol_info *rd = reloc_data;
   if(rd){
      while(!rd->IsLast()){
         if(rd->flags&SI_TEMPLATE){
            dword *dest = (dword*)table_templ.begin();
            (byte*&)dest += rd->address;
            switch(rd->type){
            case SI_DATAOFFSET: *dest += (dword)data.begin(); break;
            case SI_CODEOFFSET: *dest += (dword)code.begin(); break;
            default: assert(0);
            }
         }
         ++rd;
      }
   }
}

//----------------------------